using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Pretender.SourceGenerator
{
    internal class PretendEntrypoint
    {
        public static PretendEntrypoint FromMethodGeneric(IInvocationOperation operation)
        {
            Debug.Assert(operation.TargetMethod.TypeArguments.Length == 1, "This should have been asserted already");
            var genericLocation = ((GenericNameSyntax)((MemberAccessExpressionSyntax)((InvocationExpressionSyntax)operation.Syntax).Expression).Name).TypeArgumentList.Arguments[0].GetLocation();
            var typeArgument = operation.TargetMethod.TypeArguments[0];
            return new PretendEntrypoint(typeArgument,
                genericLocation);
        }

        public PretendEntrypoint(ITypeSymbol typeToPretend, Location invocationLocation)
        {
            TypeToPretend = typeToPretend;

            InvocationLocation = invocationLocation;

            // TODO: Do more diagnostics
            if (TypeToPretend.IsSealed)
            {
                Diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.UnableToPretendSealedType,
                    invocationLocation,
                    TypeToPretend));
            }

            PretendName = TypeToPretend.ToPretendName();
        }

        public ITypeSymbol TypeToPretend { get; }
        public Location InvocationLocation { get; }
        public string PretendName { get; }
        public List<Diagnostic> Diagnostics { get; } = new List<Diagnostic>();

        public CompilationUnitSyntax GetCompilationUnit()
        {
            var fieldAssignment = ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("_pretend"), IdentifierName("pretend")));

            var constructor = ConstructorDeclaration(PretendName)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithParameterList(ParameterList(SingletonSeparatedList(CreateConstructorParameter())))
                .WithBody(Block(fieldAssignment))
                .WithInheritDoc();

            var groupedMethods = TypeToPretend.GetGroupedMethods();

            var staticMethodInfoCache = new List<FieldDeclarationSyntax>();
            var methodDeclarations = new List<MethodDeclarationSyntax>();
            foreach (var groupedMethod in groupedMethods.Select(m => m.GetEquivalentMethodSignatures()))
            {
                var methods = groupedMethod.ToList();
                for (int i = 0; i < methods.Count; i++)
                {
                    var method = methods[i];
                    staticMethodInfoCache.Add(GetStaticMethodCacheField(method.MethodSymbol, i));
                    methodDeclarations.Add(CreateMethodBody(method.MethodSymbol, method.MethodDeclaration, i));
                }
            }

            // TODO: Support properties
            var properties = TypeToPretend.GetMembers()
                .OfType<IPropertySymbol>();

            var instanceField = FieldDeclaration(VariableDeclaration(GetGenericPretendType(), SingletonSeparatedList(VariableDeclarator(Identifier("_pretend")))))
                .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword)))
                .WithTrailingTrivia(CarriageReturnLineFeed);

            var members = new List<MemberDeclarationSyntax>();
            members.AddRange(staticMethodInfoCache);
            members.Add(instanceField);
            members.Add(constructor);
            members.AddRange(methodDeclarations);

            // TODO: Add properties

            // TODO: Generate debugger display
            var classDeclaration = ClassDeclaration(PretendName)
                .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword)))
                .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(SimpleBaseType(ParseTypeName(TypeToPretend.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))))
                .WithMembers(List(members));

            SyntaxTriviaList leadingTrivia = TriviaList(
                Comment("// <auto-generated/>"),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
                Comment("/// <inheritdoc/>"));

            return CompilationUnit()
                .AddMembers(classDeclaration.WithLeadingTrivia(leadingTrivia))
                .WithLeadingTrivia(leadingTrivia)
                .NormalizeWhitespace();
        }

        private ParameterSyntax CreateConstructorParameter()
        {
            return Parameter(Identifier("pretend"))
                .WithType(GetGenericPretendType());
        }

        private TypeSyntax GetGenericPretendType()
        {
            return GenericName(Identifier("global::Pretender.Pretend"),
                    TypeArgumentList(SingletonSeparatedList(ParseTypeName(TypeToPretend.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))));
        }

        private FieldDeclarationSyntax GetStaticMethodCacheField(IMethodSymbol method, int index)
        {
            // TODO: Get method info via argument types
            return FieldDeclaration(VariableDeclaration(ParseTypeName("global::System.Reflection.MethodInfo")))
                .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword))
                .AddDeclarationVariables(VariableDeclarator(Identifier($"__methodInfo_{method.Name}_{index}"))
                    .WithInitializer(EqualsValueClause(
                        InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, TypeOfExpression(ParseTypeName(TypeToPretend.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))), IdentifierName("GetMethod")))
                        .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(ParseExpression($"nameof({method.Name})"))))))));
        }

        private MethodDeclarationSyntax CreateMethodBody(IMethodSymbol method, MethodDeclarationSyntax methodDeclaration, int index)
        {
            var methodBodyStatements = new List<StatementSyntax>();



            var collectionExpression = CollectionExpression()
                .AddElements(method.Parameters.Select(p =>
                {
                    return ExpressionElement(IdentifierName(p.Name));
                }).ToArray());

            // ReadOnlySpan<object?> arguments = [arg0, arg1];

            var argumentsDeclaration = LocalDeclarationStatement(
                VariableDeclaration(
                    // ReadOnlySpan<object?>
                    GenericName("Span").AddTypeArgumentListArguments(NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword))))
                )
                .AddVariables(VariableDeclarator("arguments")
                    .WithInitializer(EqualsValueClause(collectionExpression))
                )
            );

            methodBodyStatements.Add(argumentsDeclaration);

            // var callInfo = new CallInfo(__methodInfo_MethodName_0, arguments);
            var callInfoCreation = LocalDeclarationStatement(
                VariableDeclaration(IdentifierName("var"))
                    .AddVariables(VariableDeclarator(Identifier("callInfo"))
                        .WithInitializer(EqualsValueClause(ObjectCreationExpression(ParseTypeName("global::Pretender.CallInfo"))
                            .AddArgumentListArguments(Argument(IdentifierName($"__methodInfo_{method.Name}_{index}")), Argument(IdentifierName("arguments")))))));

            methodBodyStatements.Add(callInfoCreation);

            // _pretend.Handle(callInfo);
            var handleCall = ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName("_pretend"),
                IdentifierName("Handle")))
                .WithArgumentList(ArgumentList(SingletonSeparatedList(
                    Argument(IdentifierName("callInfo")).WithRefKindKeyword(Token(SyntaxKind.RefKeyword))))));

            methodBodyStatements.Add(handleCall);

            if (method.ReturnType.SpecialType != SpecialType.System_Void)
            {
                var returnStatement = ReturnStatement(CastExpression(
                        ParseTypeName(method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)),
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("callInfo"), IdentifierName("ReturnValue"))));

                methodBodyStatements.Add(returnStatement);
            }

            // TODO: Assign out parameters

            return methodDeclaration
                .WithBody(Block(methodBodyStatements));
        }
    }
}
