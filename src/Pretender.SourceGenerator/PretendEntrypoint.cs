using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Pretender.SourceGenerator
{
    internal class PretendEntrypoint
    {
        public static PretendEntrypoint FromMethodGeneric(IInvocationOperation operation)
        {
            Debug.Assert(operation.TargetMethod.TypeArguments.Length == 1, "This should have been asserted already");
            var genericLocation = ((GenericNameSyntax)((MemberAccessExpressionSyntax)((InvocationExpressionSyntax)operation.Syntax).Expression).Name).TypeArgumentList.Arguments[0].GetLocation();
            var typeArgument = operation.TargetMethod.TypeArguments[0];
            return new PretendEntrypoint(typeArgument,
                genericLocation);
        }

        public PretendEntrypoint(ITypeSymbol typeToPretend, Location invocationLocation)
        {
            TypeToPretend = typeToPretend;

            InvocationLocation = invocationLocation;

            // TODO: Do more diagnostics
            if (TypeToPretend.IsSealed)
            {
                Diagnostics.Add(Diagnostic.Create(
                    DiagnosticDescriptors.UnableToPretendSealedType,
                    invocationLocation,
                    TypeToPretend));
            }

            PretendName = GetPretendName(TypeToPretend);
        }

        public ITypeSymbol TypeToPretend { get; }
        public Location InvocationLocation { get; }
        public string PretendName { get; }
        public List<Diagnostic> Diagnostics { get; } = new List<Diagnostic>();

        public CompilationUnitSyntax GetCompilationUnit()
        {
            var fieldAssignment = ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, IdentifierName("_pretend"), IdentifierName("pretend")));

            var constructor = ConstructorDeclaration(PretendName)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithParameterList(ParameterList(SingletonSeparatedList(CreateConstructorParameter())))
                .WithBody(Block(fieldAssignment))
                .WithInheritDoc();

            var groupedMethods = TypeToPretend.GetGroupedMethods();

            var staticMethodInfoCache = new List<FieldDeclarationSyntax>();
            var methodDeclarations = new List<MethodDeclarationSyntax>();
            foreach (var groupedMethod in groupedMethods.Select(m => m.GetEquivalentMethodSignatures()))
            {
                var methods = groupedMethod.ToList();
                for (int i = 0; i < methods.Count; i++)
                {
                    var method = methods[i];
                    staticMethodInfoCache.Add(GetStaticMethodCacheField(method.MethodSymbol, i));
                    methodDeclarations.Add(CreateMethodBody(method.MethodSymbol, method.MethodDeclaration, i));
                }
            }

            // TODO: Support properties
            var properties = TypeToPretend.GetMembers()
                .OfType<IPropertySymbol>();

            var instanceField = FieldDeclaration(VariableDeclaration(GetGenericPretendType(), SingletonSeparatedList(VariableDeclarator(Identifier("_pretend")))))
                .WithModifiers(TokenList(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.ReadOnlyKeyword)))
                .WithTrailingTrivia(CarriageReturnLineFeed);

            var members = new List<MemberDeclarationSyntax>();
            members.AddRange(staticMethodInfoCache);
            members.Add(instanceField);
            members.Add(constructor);
            members.AddRange(methodDeclarations);

            // TODO: Add properties

            // TODO: Generate debugger display
            var classDeclaration = ClassDeclaration(PretendName)
                .WithModifiers(TokenList(Token(SyntaxKind.InternalKeyword)))
                .WithBaseList(BaseList(SingletonSeparatedList<BaseTypeSyntax>(SimpleBaseType(ParseTypeName(TypeToPretend.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))))
                .WithMembers(List(members));

            SyntaxTriviaList leadingTrivia = TriviaList(
                Comment("// <auto-generated/>"),
                Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)),
                Comment("/// <inheritdoc/>"));

            return CompilationUnit()
                .AddMembers(classDeclaration.WithLeadingTrivia(leadingTrivia))
                .WithLeadingTrivia(leadingTrivia)
                .NormalizeWhitespace();
        }

        private ParameterSyntax CreateConstructorParameter()
        {
            return Parameter(Identifier("pretend"))
                .WithType(GetGenericPretendType());
        }

        private TypeSyntax GetGenericPretendType()
        {
            return GenericName(Identifier("global::Pretender.Pretend"),
                    TypeArgumentList(SingletonSeparatedList(ParseTypeName(TypeToPretend.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)))));
        }

        private FieldDeclarationSyntax GetStaticMethodCacheField(IMethodSymbol method, int index)
        {
            // TODO: Get method info via argument types
            return FieldDeclaration(VariableDeclaration(ParseTypeName("global::System.Reflection.MethodInfo")))
                .AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword), Token(SyntaxKind.ReadOnlyKeyword))
                .AddDeclarationVariables(VariableDeclarator(Identifier($"__methodInfo_{method.Name}_{index}"))
                    .WithInitializer(EqualsValueClause(
                        InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, TypeOfExpression(ParseTypeName(TypeToPretend.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))), IdentifierName("GetMethod")))
                        .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(ParseExpression($"nameof({method.Name})"))))))));
        }

        private MethodDeclarationSyntax CreateMethodBody(IMethodSymbol method, MethodDeclarationSyntax methodDeclaration, int index)
        {
            var methodBodyStatements = new List<StatementSyntax>();

            // var arguments = new object?[n];
            var argumentArrayCreation = LocalDeclarationStatement(
                    VariableDeclaration(IdentifierName("var"), SingletonSeparatedList(
                        VariableDeclarator(Identifier("arguments"), null, EqualsValueClause(
                            ArrayCreationExpression(ArrayType(NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword))), SingletonList(ArrayRankSpecifier(SingletonSeparatedList<ExpressionSyntax>(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(method.Parameters.Length))))))))))));

            methodBodyStatements.Add(argumentArrayCreation);

            for (int i = 0; i < method.Parameters.Length; i++)
            {
                var parameter = method.Parameters[i];

                // arguments[0] = firstArg;
                var parameterAssignment = ExpressionStatement(AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                    left: ElementAccessExpression(IdentifierName("arguments"), BracketedArgumentList(SingletonSeparatedList(Argument(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(i)))))),
                    right: IdentifierName(parameter.Name)));

                methodBodyStatements.Add(parameterAssignment);
            }

            // var callInfo = new CallInfo(__methodInfo_MethodName_0, arguments);
            var callInfoCreation = LocalDeclarationStatement(
                VariableDeclaration(IdentifierName("var"))
                    .AddVariables(VariableDeclarator(Identifier("callInfo"))
                        .WithInitializer(EqualsValueClause(ObjectCreationExpression(ParseTypeName("global::Pretender.CallInfo"))
                            .AddArgumentListArguments(Argument(IdentifierName($"__methodInfo_{method.Name}_{index}")), Argument(IdentifierName("arguments")))))));

            methodBodyStatements.Add(callInfoCreation);

            // _pretend.Handle(callInfo);
            var handleCall = ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName("_pretend"),
                IdentifierName("Handle")))
                .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(IdentifierName("callInfo"))))));

            methodBodyStatements.Add(handleCall);

            if (method.ReturnType.SpecialType != SpecialType.System_Void)
            {
                var returnStatement = ReturnStatement(CastExpression(
                        ParseTypeName(method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)),
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("callInfo"), IdentifierName("ReturnValue"))));

                methodBodyStatements.Add(returnStatement);
            }

            // TODO: Assign out parameters

            return methodDeclaration
                .WithBody(Block(methodBodyStatements));
        }

        private static string GetPretendName(ITypeSymbol typeToPretend)
        {
            // TODO: This logic won't work if someone has two distinct types that have the same name
            // I will probably need to introduce randomness but will need to intercept `Create` before I do that probably.

            if (typeToPretend.TypeKind == TypeKind.Interface)
            {
                // Interfaces generally have an I prefix, we will try to strip it off
                if (typeToPretend.Name.StartsWith("I")
                    && typeToPretend.Name.Length > 1
                    && typeToPretend.Name[1] == char.ToUpper(typeToPretend.Name[1]))
                {
                    return typeToPretend.Name.Substring(1) + "PretendImplementation";
                }
            }

            return typeToPretend.Name + "PretendImplementation";
        }
    }
}
