// <auto-generated>

#nullable enable annotations
#nullable disable warnings

// Suppress warnings about [Obsolete] member usage in generated code.
#pragma warning disable CS0612, CS0618

namespace System.Runtime.CompilerServices
{
    using System;
    using System.CodeDom.Compiler;

    [GeneratedCode("Pretender.SourceGenerator", "1.0.0.0")]
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Pretender.SourceGeneration
{
    using System;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Threading.Tasks;
    using Pretender;
    using Pretender.Internals;

    file class PretendIMyInterface : global::TaskOfTMethodNamespace.IMyInterface
    {
        public static readonly MethodInfo MethodAsync_MethodInfo = typeof(PretendIMyInterface).GetMethod(nameof(MethodAsync))!;

        private readonly ICallHandler _callHandler;

        public PretendIMyInterface(ICallHandler callHandler)
        {
            _callHandler = callHandler;
        }

        public global::System.Threading.Tasks.Task<string> MethodAsync(string str)
        {
            object?[] __arguments__ = [str];
            var __callInfo__ = new CallInfo(MethodAsync_MethodInfo, __arguments__);
            _callHandler.Handle(__callInfo__);
            return (global::System.Threading.Tasks.Task<string>)__callInfo__.ReturnValue;
        }
    }

    file static class SetupInterceptors
    {
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "uNYJO7f/XsEA3+a79KlSmqABAABNeVRlc3QuY3M=")]
        internal static IPretendSetup<global::TaskOfTMethodNamespace.IMyInterface, global::System.Threading.Tasks.Task<string>> Setup0(this Pretend<global::TaskOfTMethodNamespace.IMyInterface> pretend, Func<global::TaskOfTMethodNamespace.IMyInterface, global::System.Threading.Tasks.Task<string>> setupExpression)
        {
            return pretend.GetOrCreateSetup<global::System.Threading.Tasks.Task<string>>(0, static (pretend, expr) =>
            {
                Matcher matchCall = (callInfo, setup) =>
                {
                    var singleUseCallHandler = new SingleUseCallHandler<global::System.Threading.Tasks.Task<string>>();
                    var fake = new PretendIMyInterface(singleUseCallHandler);

                    var listener = MatcherListener.StartListening();
                    try
                    {
                        setup.Method.Invoke(setup.Target, [fake]);
                    }
                    finally
                    {
                        listener.Dispose();
                    }

                    var capturedArguments = singleUseCallHandler.Arguments;

                    var str_capturedMatcher = listener.Matchers[0];
                    var str_arg = (string)callInfo.Arguments[0];
                    if (!str_capturedMatcher.Matches(str_arg))
                    {
                        return false;
                    }
                    return true;
                };
                return new ReturningCompiledSetup<global::TaskOfTMethodNamespace.IMyInterface, global::System.Threading.Tasks.Task<string>>(pretend, PretendIMyInterface.MethodAsync_MethodInfo, matchCall, expr, defaultValue: default);
            }, setupExpression);
        }
    }

    file static class VerifyInterceptors
    {
    }

    file static class CreateInterceptors
    {
    }
}